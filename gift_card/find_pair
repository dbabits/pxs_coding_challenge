#!/bin/bash

usage() {
   echo "
   Goal:
        Write a program to find the best two items. It takes two inputs:
        1. A filename with a list of sorted prices
        2. The balance of your gift card
        If no two items have a sum that is less than or equal to the balance on the gift card, print 'Not possible'

   Usage: 
        $0 filename giftcard_balance
   
   Sample run:

        $0 prices.txt 2300

        rowid       rowid       combination                  first_price  second_price  summ
        ----------  ----------  ---------------------------  -----------  ------------  ----------
        2           4           Paperback Book + Headphones   700          1400         2100

   The file is expected to be in this format:
        $ cat prices.txt
        Candy Bar, 500
        Paperback Book, 700
        Detergent, 1000
        Headphones, 1400
        Earmuffs, 2000
        Bluetooth Stereo, 6000

   Test cases:
        $0 `dirname $0`/prices.txt 2500
            Candy Bar 500, Earmuffs 2000

        $0 `dirname $0`/prices.txt 2300
            Paperback Book 700, Headphones 1400

        $0 `dirname $0`/prices.txt 10000
            Earmuffs 2000, Bluetooth Stereo 6000

        $0 `dirname $0`/prices.txt 1100
            Not possible


   This program depends on sqlite csv extension, included in the distribution
   It works by cross-joining the same table to itself, filtering by sum of prices and excluding permutations of the same combination (e.g. (a,b) is same as (b,a)
   The file is not loaded into memory nor converted into sqlite's format,but simply mapped. 
   It does not do it optimally because the file is sorted, and it doesn't take advantage of it.
   However, I though it's elegant and deserves to be shown.
   Converting to sqlite format would likely speed it up because an index can be created which will take advantage of sort.

   Big O: O(n^2) if file is mapped (without indexing).
          O(n log n) if index is used (can be clustered which will take advantage of pre-sorted data) 

   Details: 
            https://sqlite.org/howtocompile.html
            https://sqlite.org/csv.html
            https://sqlite.org/loadext.html

            Actual commands used for compilation are in sqlite-amalgamation-3200000/build
   "
   exit 1
}

tempfile=$(mktemp) || exit 42
trap "rm $tempfile" EXIT

filename=$1
giftcard_balance=$2

[ -n "$filename" ] && echo filename=$filename || usage
[ -n "$giftcard_balance" ] && echo giftcard_balance=$giftcard_balance || usage


cat <<EOF | `dirname $0`/sqlite-amalgamation-3200000/sqlite3 -header -column #| tee >(grep --count summ)
SELECT load_extension('`dirname $0`/sqlite-amalgamation-3200000/csv') as ''; --csv.so, compiled separately is loaded this way. Also can do: .load path/csv

CREATE VIRTUAL TABLE temp.t USING csv(filename='$filename');

.once $tempfile
SELECT t1.rowid,t2.rowid, t1.c0 || " + " || t2.c0 as combination, t1.c1 as first_price, t2.c1 as second_price, t1.c1+t2.c1 as summ 
FROM t t1, t t2 
WHERE t1.rowid < t2.rowid   --we need combinations, not permutations: (a,b) considered same as  (b,a), hence <
   and summ<=$giftcard_balance
ORDER BY summ DESC
LIMIT 1;
EOF

grep --quiet summ $tempfile #if there are no rows returned, there won't be no header line with summ
[ $? -eq 0 ] && cat $tempfile || echo "Not possible"


